
use std::process::Command;
use std::env;
use std::fs;
use std::io::{self, Read, Seek, SeekFrom, Write};

fn main() -> io::Result<()> {

    // Ensure that we rerun if the API changes.
    println!("cargo:rerun-if-changed=../../emily/api-definition/models");
    println!("cargo:rerun-if-changed=build.rs");

    // Go to the workspace root directory.
    let crate_dir = env::current_dir().unwrap();
    let workspace_dir = crate_dir
        .join("..")
        .join("..");

    // Move execution location.
    assert!(
        env::set_current_dir(workspace_dir).is_ok(),
        "Couldn't change to the project root directory.",
    );

    // Run `make emily-client-source`.
    let make_emily_client_source: std::process::ExitStatus = Command::new("make")
        .args(["emily-client-source"])
        .status()
        .expect("Failed to run `make emily-client-source`.");

    // Fail if the command failed.
    assert!(
        make_emily_client_source.success(),
        "make emily-client-source failed.",
    );

    // Update `lib.rs` to have directives at the top that will stop clippy from roasting
    // the the autogenerated code.
    assert!(
        env::set_current_dir(crate_dir).is_ok(),
        "Couldn't change back to the crate directory.",
    );

    // Specify the types of clippy linting to ignore; keep security related ones around
    // just in case.
    let directives = "#![allow(clippy::style)]\n#![allow(clippy::too_many_arguments)]";

    let path = "src/lib.rs";
    let mut file = fs::OpenOptions::new().read(true).write(true).open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;

    // Check if the directives were already inserted.
    if !contents.contains(directives) { // The lib file isn't very long.
        let mut new_contents = format!("{}\n", directives).to_string();
        new_contents.push_str(&contents);

        // Set the file seek pointer to the top of the file so we add the directives
        // to the top of the file.
        file.seek(SeekFrom::Start(0))?;
        file.write_all(new_contents.as_bytes())?;
    }

    // Return
    Ok(())
}
