
use std::process::Command;
use std::env;
use std::fs;
use std::io::{self, Read, Seek, SeekFrom, Write};

fn main() -> io::Result<()> {

    // Ensure that we rerun if the API changes.
    println!("cargo:rerun-if-changed=../../emily/api-definition/models");
    println!("cargo:rerun-if-changed=build.rs");

    // Go to the api directory.
    let root_dir = env::current_dir().unwrap();
    let emily_api_dir = root_dir
        .join("..")
        .join("..")
        .join("emily")
        .join("api-definition");

    // Move execution location.
    assert!(
        env::set_current_dir(emily_api_dir).is_ok(),
        "Couldn't change to the emily/api-definition directory.",
    );

    // Run `npm install`.
    let npm_install = Command::new("npm")
        .args(["install"])
        .status()
        .expect("Failed to run `npm install`.");

    // Fail if the install command failed.
    assert!(
        npm_install.success(),
        "npm install failed.",
    );

    // Run `npm run build`.
    let npm_build = Command::new("npm")
        .args(["run", "build"])
        .status()
        .expect("Failed to run `npm run build`.");

    // Fail if the build command failed.
    assert!(
        npm_build.success(),
        "npm run build failed.",
    );

    // Update `lib.rs` to have directives at the top that will stop clippy from roasting
    // the the autogenerated code.
    assert!(
        env::set_current_dir(root_dir).is_ok(),
        "Couldn't change back to the build directory.",
    );

    // Specify the types of clippy linting to ignore; keep security related ones around
    // just in case.
    let directives = "#![allow(clippy::style)]\n#![allow(clippy::too_many_arguments)]";

    let path = "src/lib.rs";
    let mut file = fs::OpenOptions::new().read(true).write(true).open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;

    // Check if the directives were already inserted.
    if !contents.contains(directives) { // The lib file isn't very long.
        let mut new_contents = format!("{}\n", directives).to_string();
        new_contents.push_str(&contents);

        // Set the file seek pointer to the top of the file so we add the directives
        // to the top of the file.
        file.seek(SeekFrom::Start(0))?;
        file.write_all(new_contents.as_bytes())?;
    }

    // Return
    Ok(())
}
